/*
  emagic emi 2|6 firmware loader for WinUSB

  Copyright (c) 2022  Kazuhiro Ito (kzhr@d1.dion.ne.jp)

  Original file is automatically generated by Visual Studio 2019.

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
*/


#include <stdio.h>
#include <windows.h>
#include <winusb.h>
#include <ntdef.h>
#include <locale.h>
#include <shlwapi.h>
#include <pathcch.h>
#include <libloaderapi.h>

#include "device.h"
#include "emi26.h"

/* emi26r.c */
LSTATUS emi26r_register_interface_guid();


static const WCHAR EMI26_FIRMWARE_DIRECTORY[] = L"emi26";
static const WCHAR *directory = NULL;


void errnum_printf_message(PCWSTR string, DWORD errnum) {
  PCWSTR message;
  FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
		 NULL, errnum, 0, (PWSTR)&message, 0, NULL);
  wprintf(L"%S, (0x%x) %S", string, (INT)errnum, message);
  LocalFree((HLOCAL)message);
}

static void show_help(PCWSTR prog_name) {
  wprintf(L"emagic emi 2|6 firmware loader for WinUSB\n");
  wprintf(L"Usage: %S [option...]\n", prog_name);
  wprintf(L"Options:\n");
  wprintf(L"  -d [directory] Load firmware files from [directory].\n");
  wprintf(L"  -r             Register interface GUID.\n");
  wprintf(L"  -h             Show this message.\n");
  wprintf(L"  -v             Show this message.\n");
}

static void setup_directory(PCWSTR prog_name) {
  if (!directory) {
    static WCHAR dirname[MAX_PATH];
    WCHAR buffer[MAX_PATH];
    HRESULT hResult;

    GetModuleFileNameW(NULL, dirname, MAX_PATH);
    hResult = PathCchCombine(buffer, MAX_PATH, dirname, L"..");
    if (hResult != S_OK) {
      wprintf(L"Can't resolve directory name\n");
      exit(-3);
    }

    hResult = PathCchCombine(dirname, MAX_PATH, buffer, EMI26_FIRMWARE_DIRECTORY);
    if (hResult != S_OK) {
      wprintf(L"Can't resolve directory name\n");
      exit(-3);
    }
    directory = dirname;
  }

  if (!PathFileExistsW(directory)) {
    wprintf(L"directory %S does not exist.\n", directory);
    exit(-2);
  }
}


static void parse_args(int argc, wchar_t* argv[]) {
  int i = 1;

  while (i < argc) {
    if (!wcscmp(argv[i], L"-d")) {
      i++;
      if (i < argc) {
	directory = argv[i];
      } else {
	wprintf(L"directory is not specified.\n");
	exit(-1);
      }
    } else if (!wcscmp(argv[i], L"-r")) {
      emi26r_register_interface_guid();
      exit(0);
    } else if (!wcscmp(argv[i], L"-h") || !wcscmp(argv[i], L"-v")) {
      show_help(argv[0]);
      exit(1);
    }
    i++;
  }
}


int wmain (int argc, wchar_t* argv[]) {
  DEVICE_DATA deviceData;
  HRESULT     hResult;
  BOOL        noDevice;

    _wsetlocale(LC_ALL, L"");

    parse_args(argc, argv);
    setup_directory(argv[0]);

    hResult = OpenDevice(&deviceData, &noDevice);

    if (hResult != S_OK) {
      if (noDevice) {
	wprintf(L"Device not connected or driver not installed.\n");
      } else {
	errnum_printf_message(L"Failed looking for devic", hResult);
      }
      return 0;
    }

    NTSTATUS ntstatus = emi26_load_firmware(deviceData.WinusbHandle, directory);
    if (!NT_SUCCESS(ntstatus)) return ntstatus;

    CloseDevice(&deviceData);
    return 0;
}
